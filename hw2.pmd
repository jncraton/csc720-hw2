% CSC720 Homework 2
% Jon Craton
% March 13, 2018

Due Date: Tuesday, Mar 13, 2018 By Midnight

## Problem 1 (20 points)

1.29 Use the pumping lemma to show that the following languages are not regular.

a\. A₁ = { 0ⁿ1ⁿ2ⁿ|n ≥ 0 }

This will be solved by applying a proof by contradiction and the pumping lemma.

Assume that A is a regular language. Let p be the pumping length from the pumping lemma. Let s be the string 0<sup>p</sup>1<sup>p</sup>2<sup>p</sup>. s is a member of A and |s| ≥ p, so the pumping lemma for regular languages applies.

The pumping lemma for regular languages states that s can be partitioned as xyz such that xyⁱz∈A where i≥0. Additionally, |y| > 0 and |xy| ≤ p. When considering the possible partition schemes for s, we see that only y=0<sup>k</sup> where k>0 and k≤p satisfies the conditions that |y| > 0 and |xy| ≤ p.

The pumping lemma tells us that xyⁱz∈A for all i≥0. However, for i=0, the zero component is completely removed from our string while 1<sup>p</sup>2<sup>p</sup> remains. The generated string is not a member of the language for all k, therefore, A is not a regular language by contradiction.

b\. A₂ = { www|w ∈ {a,b}* }

This will be solved by applying a proof by contradiction and the pumping lemma.

Assume that A is a regular language. Let p be the pumping length from the pumping lemma. Let s be the string a<sup>p</sup>a<sup>p</sup>a<sup>p</sup>. s is a member of A and |s| ≥ p, so the pumping lemma for regular languages applies.

The pumping lemma for regular languages states that s can be partitioned as xyz such that xyⁱz∈A where i≥0. Additionally, |y| > 0 and |xy| ≤ p. When considering the possible partition schemes for s, we see that only x=ɛ,y=a<sup>k</sup>,z=a<sup>k</sup>a<sup>k</sup> where k>0 and k≤p satisfies the conditions that |y| > 0 and |xy| ≤ p.

The pumping lemma tells us that xyⁱz∈A for all i≥0. However, for i=0, the first copy of our language w is completely removed from our string while a<sup>k</sup>a<sup>k</sup> remains. The generated string is not a member of the language for all k (when p=1, the string contains a number of a's that is not a multiple of 3), therefore, A is not a regular language by contradiction.

## Problem 2 (20 points)

2.4 Give context-free grammars that generate the following languages. In all parts the alphabet Σ is {0, 1}.

b\. {w | w starts and ends with the same symbol}

```python
from nltk import CFG

grammar = CFG.fromstring("""
S -> '0' Any '0'
S -> '1' Any '1'
S -> '0' | '1'
Any -> '0' Any
Any -> '1' Any
Any ->
""")

from nltk.parse.generate import generate

print([''.join(s) for s in generate(grammar, depth=5)])
```

c\. {w | the length of w is odd|

```python
grammar = CFG.fromstring("""
S -> OneCount EvenCount
OneCount -> '0' | '1'
EvenCount -> OneCount OneCount
EvenCount -> 
""")

print([''.join(s) for s in generate(grammar, depth=5)])
```

(10 points) Figure 2.17 shows a push down automata which recognizes
{a^i^b^j^c^k^| i, j, k≥0 and i=j or i=k}. Please design and draw a new
push down automata which recognizes {a^i^b^j^c^k^| i, j, k≥0 and i≥j or
i≥k}.

![](./media/image1.png)

Here's the orignal in JFLAP:

![](pda.png)

Basically, this needs to be amended to also accept i > j or i > k. Let's make sure the orignal does what we expect first:

![](pda-test.png)

Now we just need to add a few transitions to allow the machine to be able to loop after it has met the desired conditions:

![](pda-adj.png)

Now we see that our test for the new mode are passing:

![](pda-adj-test.png)

(10 points) 2.14 Convert the following CFG into an equivalent CFG in
Chomsky normal form, using the procedure given in Theorem 2.9.

    A→BAB|B|ε
    B→00|ε

Step 1: Rename start variable

There is no start variable.

    A→BAB|B|ε
    B→00|ε

Step 2: Remove ε rules

For B:

    A→BAB|B|ε|A
    B→00

Then for A:

    A→BAB|B|A|BB
    B→00

Step 3a: Remove identity unit rules

    A→BAB|B|BB
    B→00

Step 3b: Remove other unit rules

    A→BAB|00|BB
    B→00

Step 4: Convert rules to proper form

    A→BB₁|00|BB
    B₁→AB
    B→00

(10 points) 2.30 Use the pumping lemma to show that the following
languages are not context free.

a\. $\left\{ 0^{n}1^{n}0^{n}1^{n} \middle| n \geq 0 \right\}$

(10 points) Answer the following two questions:

a.  Briefly describe how regular language is used for lexical analysis
    in a compiler.

Regular language is commonly used in lexical analysis to convert segments of text (lexemes) into tokens. If a segment of text matches a token rule, it is converted to a token. Tokens have a both a name and a value.

b.  Briefly describe how context free language is used for parsing
    (syntax analysis) in a compiler.

Once tokenized, the syntax of a segment of text can be parsed for syntax analysis. The overall syntax of many common programming langauges is context-free, so the syntax is matched to a context-free grammar.

(20 points) Programming Assignments

This programming assignment assumes you have a Linux compiling
environment. If you don’t have one, setting up a Linux machine in a
VirtualBox or VMware Player is a quick way to get a Linux development
environment. If you need help to set up a Linux virtual machine, let me
know.

Assume you have an Ubuntu Linux, you need to install additional packages
to complete the lab. These packages include, flex and bison. You can
install these packages by running the following commands:

&gt;apt-get install flex

&gt;apt-get install bison

A homework2.zip file has been posted in the class website. The zip file
includes three folders, q1, q2, and q3. Each folder contains the
necessary files to finish each question.

**(4 points)** 1) When you use gcc compile a program, e.g., hello.c

&gt;gcc hello.c –o hello

It will create a binary file. You can also check the temporary output
files created by gcc using option –save-temps. Try

&gt;gcc hello.c –o hello –save-temps

and find out what intermediate output files can be produced by gcc.
Briefly describe each intermediate output file.

A typical C compilation pipeline is handled in 4 phases using 4 distinct tools:

### 1. Pre-processor

The pre-processor expands macros and handle includes. In a nutshell, it takes care of anything starting with `#`. With `--save-temps` the output of this phase is stored in `hello.i`. This output is valid C code. Our `hello.c` program is still fundamentally the same with a lot of `#include` inlining:

    # 1 "hello.c"
    # 1 "<built-in>"
    # 1 "<command-line>"
    # 1 "/usr/include/stdc-predef.h" 1 3 4
    # 1 "<command-line>" 2
    
    ... (trimmed ~1900 lines)

    void main()
    {
     printf("hello world\n");
    }


### 2. Compiler

The compiler converts pre-processed C code into assembly instructions. It's worth noting that while an intermediate human-readable representation is handy, it isn't strictly necessary. Compilation could output machine code directly, but using intermediate assembly modularizes the tool chain. Also, because C allows inline assembly, you need a full assembler in either case. This intermediate representation also doesn't need to actually be assembly language instructions for the target platform. For example, LLVM uses a platform independent intermediate representation.

The output of this step is stored in `hello.s`, and is stored as assembly instructions still viewable as text:

    .file	"hello.c"
    .section	.rodata
    .LC0:
    .string	"hello world"
    .text
    .globl	main
    .type	main, @function
    main:
    .LFB2:
    .cfi_startproc
    pushq	%rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq	%rsp, %rbp
    .cfi_def_cfa_register 6
    movl	$.LC0, %edi
    call	puts
    nop
    popq	%rbp
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc
    .LFE2:
    .size	main, .-main
    .ident	"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609"
    .section	.note.GNU-stack,"",@progbits

### 3. Assembler

The assembler converts assembly instructions to machine code. The output of this stage is stored as `hello.o`. This stage is notable as this output is frequently generated as part of a "normal" build process. Typically, many C files are assembled and then linked into a single final executable.

Being machine code, we can't easily view .o files directly. GCC does include a tool called objdump to allow us to disassemble obejct files. Here's the output of `objdump -D hello.o` to demonstrate that the object file basically contains our previous assembly code as machine code:

    hello.o:     file format elf64-x86-64
     
     
     Disassembly of section .text:
     
     0000000000000000 <main>:
        0:	55                   	push   %rbp
        1:	48 89 e5             	mov    %rsp,%rbp
        4:	bf 00 00 00 00       	mov    $0x0,%edi
        9:	e8 00 00 00 00       	callq  e <main+0xe>
        e:	90                   	nop
        f:	5d                   	pop    %rbp
       10:	c3                   	retq   
     
     Disassembly of section .rodata:
     
     0000000000000000 <.rodata>:
        0:	68 65 6c 6c 6f       	pushq  $0x6f6c6c65
        5:	20 77 6f             	and    %dh,0x6f(%rdi)
        8:	72 6c                	jb     76 <main+0x76>
        a:	64                   	fs
     	...
     
     Disassembly of section .comment:
     
     0000000000000000 <.comment>:
        0:	00 47 43             	add    %al,0x43(%rdi)
        3:	43 3a 20             	rex.XB cmp (%r8),%spl
        6:	28 55 62             	sub    %dl,0x62(%rbp)
        9:	75 6e                	jne    79 <main+0x79>
        b:	74 75                	je     82 <main+0x82>
        d:	20 35 2e 34 2e 30    	and    %dh,0x302e342e(%rip)        # 302e3441 <main+0x302e3441>
       13:	2d 36 75 62 75       	sub    $0x75627536,%eax
       18:	6e                   	outsb  %ds:(%rsi),(%dx)
       19:	74 75                	je     90 <main+0x90>
       1b:	31 7e 31             	xor    %edi,0x31(%rsi)
       1e:	36 2e 30 34 2e       	ss xor %dh,%cs:(%rsi,%rbp,1)
       23:	39 29                	cmp    %ebp,(%rcx)
       25:	20 35 2e 34 2e 30    	and    %dh,0x302e342e(%rip)        # 302e3459 <main+0x302e3459>
       2b:	20 32                	and    %dh,(%rdx)
       2d:	30 31                	xor    %dh,(%rcx)
       2f:	36 30 36             	xor    %dh,%ss:(%rsi)
       32:	30 39                	xor    %bh,(%rcx)
     	...
     
     Disassembly of section .eh_frame:
     
     0000000000000000 <.eh_frame>:
        0:	14 00                	adc    $0x0,%al
        2:	00 00                	add    %al,(%rax)
        4:	00 00                	add    %al,(%rax)
        6:	00 00                	add    %al,(%rax)
        8:	01 7a 52             	add    %edi,0x52(%rdx)
        b:	00 01                	add    %al,(%rcx)
        d:	78 10                	js     1f <.eh_frame+0x1f>
        f:	01 1b                	add    %ebx,(%rbx)
       11:	0c 07                	or     $0x7,%al
       13:	08 90 01 00 00 1c    	or     %dl,0x1c000001(%rax)
       19:	00 00                	add    %al,(%rax)
       1b:	00 1c 00             	add    %bl,(%rax,%rax,1)
       1e:	00 00                	add    %al,(%rax)
       20:	00 00                	add    %al,(%rax)
       22:	00 00                	add    %al,(%rax)
       24:	11 00                	adc    %eax,(%rax)
       26:	00 00                	add    %al,(%rax)
       28:	00 41 0e             	add    %al,0xe(%rcx)
       2b:	10 86 02 43 0d 06    	adc    %al,0x60d4302(%rsi)
       31:	4c 0c 07             	rex.WR or $0x7,%al
       34:	08 00                	or     %al,(%rax)
     	...

### 4. Linker

The linker merges object file(s) into a single final executable. It adds necessary bootstraping code to start execution, handles environment variables, command line arguments, and other things.

It converts references to external code to the correct locations. The linker may run dynamically to call into dynamically loaded dependencies, or it can be run statically to include all dependencies directly in the final binary.

The output of this stage is the final executable, `hello`. This stage is also hard to view directly, but we can still use `objdump` to convert it to assembly for debugging:

    q1/hello:     file format elf64-x86-64
    
    
    Disassembly of section .init:
    
    00000000004003c8 <_init>:
      4003c8:	48 83 ec 08          	sub    $0x8,%rsp
      4003cc:	48 8b 05 25 0c 20 00 	mov    0x200c25(%rip),%rax        # 600ff8 <_DYNAMIC+0x1d0>
      4003d3:	48 85 c0             	test   %rax,%rax
      4003d6:	74 05                	je     4003dd <_init+0x15>
      4003d8:	e8 43 00 00 00       	callq  400420 <__libc_start_main@plt+0x10>
      4003dd:	48 83 c4 08          	add    $0x8,%rsp
      4003e1:	c3                   	retq   
    
    Disassembly of section .plt:
    
    00000000004003f0 <puts@plt-0x10>:
      4003f0:	ff 35 12 0c 20 00    	pushq  0x200c12(%rip)        # 601008 <_GLOBAL_OFFSET_TABLE_+0x8>
      4003f6:	ff 25 14 0c 20 00    	jmpq   *0x200c14(%rip)        # 601010 <_GLOBAL_OFFSET_TABLE_+0x10>
      4003fc:	0f 1f 40 00          	nopl   0x0(%rax)
    
    0000000000400400 <puts@plt>:
      400400:	ff 25 12 0c 20 00    	jmpq   *0x200c12(%rip)        # 601018 <_GLOBAL_OFFSET_TABLE_+0x18>
      400406:	68 00 00 00 00       	pushq  $0x0
      40040b:	e9 e0 ff ff ff       	jmpq   4003f0 <_init+0x28>
    
    0000000000400410 <__libc_start_main@plt>:
      400410:	ff 25 0a 0c 20 00    	jmpq   *0x200c0a(%rip)        # 601020 <_GLOBAL_OFFSET_TABLE_+0x20>
      400416:	68 01 00 00 00       	pushq  $0x1
      40041b:	e9 d0 ff ff ff       	jmpq   4003f0 <_init+0x28>
    
    Disassembly of section .plt.got:
    
    0000000000400420 <.plt.got>:
      400420:	ff 25 d2 0b 20 00    	jmpq   *0x200bd2(%rip)        # 600ff8 <_DYNAMIC+0x1d0>
      400426:	66 90                	xchg   %ax,%ax
    
    Disassembly of section .text:
    
    0000000000400430 <_start>:
      400430:	31 ed                	xor    %ebp,%ebp
      400432:	49 89 d1             	mov    %rdx,%r9
      400435:	5e                   	pop    %rsi
      400436:	48 89 e2             	mov    %rsp,%rdx
      400439:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
      40043d:	50                   	push   %rax
      40043e:	54                   	push   %rsp
      40043f:	49 c7 c0 b0 05 40 00 	mov    $0x4005b0,%r8
      400446:	48 c7 c1 40 05 40 00 	mov    $0x400540,%rcx
      40044d:	48 c7 c7 26 05 40 00 	mov    $0x400526,%rdi
      400454:	e8 b7 ff ff ff       	callq  400410 <__libc_start_main@plt>
      400459:	f4                   	hlt    
      40045a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    
    ... (snipped)

**(8 points)** 2) The flex file, calc.lex, is a simple calculator. You
can compile the file with the following commands:

&gt; flex calc.lex; gcc -o calc lex.yy.c

You can then run the calculator with the 'calc' command and can quit out
of it using ctrl-d.

Do the following and submitted your modified code:

### Add division and subtraction to the calculator.

Here's the patch to implement this:

    diff --git a/q2/calc.lex b/q2/calc.lex
    index 101c022..01e6612 100644
    --- a/q2/calc.lex
    +++ b/q2/calc.lex
    @@ -32,7 +32,9 @@ struct tokenInfo2 yylval;
     
     :=    printf("ASSIGNMENT\n");
     \+     printf("PLUS\n");
    +\-     printf("MINUS\n");
     \*     printf("MULTIPLY\n");
    +\/     printf("DIVIDE\n");
     
     \n    printf("NEWLINE\n");

### Keep track of the number of lines that have been input

Make sure that you set the lineNumber variable in yylval.ti for each token and print out the line count when you print out variable information.

Here's the patch to implement this:

    diff --git a/q2/calc.lex b/q2/calc.lex
    index 01e6612..b91c8a0 100644
    --- a/q2/calc.lex
    +++ b/q2/calc.lex
    @@ -21,7 +21,7 @@ struct tokenInfo2 yylval;
     [a-z]   {
     	   yylval.ti.value = 0;
     	   yylval.ti.name =  (char *) strdup(yytext);
    -	   printf("VARIABLE: %s\n", yylval.ti.name);
    +	   printf("VARIABLE: %s LINES: %d\n", yylval.ti.name, yylval.ti.lineNumber);
             }
     
     [0-9]+  {  
    @@ -36,7 +36,10 @@ struct tokenInfo2 yylval;
     \*     printf("MULTIPLY\n");
     \/     printf("DIVIDE\n");
     
    -\n    printf("NEWLINE\n");
    +\n      {
    +           printf("NEWLINE\n");
    +           yylval.ti.lineNumber += 1;
    +        }
     
     [ \t]   ;

### Extend the variables to handle longer variable names

The variables must start with an alphabetic character or '\_' character and may be followed by 0 or more alphabetic/numerical/'\_'/'-' characters.

Here's the patch to implement this:

    diff --git a/q2/calc.lex b/q2/calc.lex
    index b91c8a0..9857abd 100644
    --- a/q2/calc.lex
    +++ b/q2/calc.lex
    @@ -18,7 +18,7 @@ struct tokenInfo2 yylval;
     
     %%
     
    -[a-z]   {
    +[a-zA-Z_][a-zA-Z0-9_\-]*   {
     	   yylval.ti.value = 0;
     	   yylval.ti.name =  (char *) strdup(yytext);
     	   printf("VARIABLE: %s LINES: %d\n", yylval.ti.name, yylval.ti.lineNumber);

**(8 points)** 3) A flex file, calc.lex, a bison file, calc.y, and a
Makefile are provide in homework2 q3 folder. You can compile the flex
file and the bison file by running

&gt;make

A binary execution file, calc, will be created.

You can then run the calculator with the 'calc' command and can quit out
of it using “quit”.

Do the following and submitted your modified code:

-   Extend the calculator to support power operator, ‘\^’. Let x, y are
    two numbers, ${x\hat{}y = x}^{y}$.

```
diff --git a/q3/Makefile b/q3/Makefile
index d002bb4..3f2fd68 100644
--- a/q3/Makefile
+++ b/q3/Makefile
@@ -7,7 +7,7 @@ lex.yy.c: calc.lex calc.tab.h
 	flex calc.lex
 
 calc: lex.yy.c calc.tab.c calc.tab.h
-	gcc -o calc calc.tab.c lex.yy.c -lfl
+	gcc -o calc calc.tab.c lex.yy.c -lfl -lm
 
 test: calc
 	echo "1+1" | ./calc | grep 2
diff --git a/q3/calc.lex b/q3/calc.lex
index 975e718..5153c79 100644
--- a/q3/calc.lex
+++ b/q3/calc.lex
@@ -16,6 +16,7 @@
 "-"	{return '-';}
 "*"	{return '*';}
 "/"	{return '/';}
+"^"	{return '^';}
 "quit"	{return QUIT;}
 
 %%
diff --git a/q3/calc.y b/q3/calc.y
index 29a338d..a2451de 100644
--- a/q3/calc.y
+++ b/q3/calc.y
@@ -20,6 +20,7 @@ void yyerror(const char* s);
 %token QUIT
 %left '+' '-'
 %left '*' '/'
+%left '^'
 
 %type<ival> exp
 
@@ -41,6 +42,7 @@ exp: NUM		{ $$ = $1; }
     | exp '-' exp	{ $$ = $1 - $3; }
     | exp '*' exp	{ $$ = $1 * $3; }
     | exp '/' exp	{ $$ = $1 / $3; }
+    | exp '^' exp	{ $$ = pow($1, $3); }
 ;
 
 %%
```

-   Extend the calculator to support parentheses, ‘(‘, and ‘)’. An
    expression inside parentheses needs to be evaluated first, e.g.,
    enter 2 \* ( 3 + 2) in the calculator and it should return 10.

```
diff --git a/q3/calc.lex b/q3/calc.lex
index 5153c79..c20788f 100644
--- a/q3/calc.lex
+++ b/q3/calc.lex
@@ -17,6 +17,8 @@
 "*"	{return '*';}
 "/"	{return '/';}
 "^"	{return '^';}
+"("	{return '(';}
+")"	{return ')';}
 "quit"	{return QUIT;}
 
 %%
diff --git a/q3/calc.y b/q3/calc.y
index a2451de..3e84c55 100644
--- a/q3/calc.y
+++ b/q3/calc.y
@@ -18,6 +18,7 @@ void yyerror(const char* s);
 
 %token<ival> NUM
 %token QUIT
+%left '(' ')'
 %left '+' '-'
 %left '*' '/'
 %left '^'
@@ -38,6 +39,7 @@ line: '\n'
 ;
 
 exp: NUM		{ $$ = $1; }
+    | '(' exp ')' { $$ = $2; }
     | exp '+' exp	{ $$ = $1 + $3; }
     | exp '-' exp	{ $$ = $1 - $3; }
     | exp '*' exp	{ $$ = $1 * $3; }

```