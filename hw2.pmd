% CSC720 Homework 2
% Jon Craton
% March 13, 2018

Due Date: Tuesday, Mar 13, 2018 By Midnight

(20 points) 1.29 Use the pumping lemma to show that the following
languages are not regular.

a\. $A_1 = \{ 0^n1^n2^n|n \geq 0 \}$

This will be solved by applying a proof by contradition and the pumping lemma.

From Wikipedia:

> For any regular language L there exists a constant p such that any word w in L with length at least p can be split into three substrings, w = xyz, where the middle portion y must not be empty, such that the words xz, xyz, xyyz, xyyyz, … constructed by repeating y zero or more times are still in L. This process of repetition is known as "pumping". Moreover, the pumping lemma guarantees that the length of xy will be at most p, imposing a limit on the ways in which w may be split.

$w = xyz = 0^n1^n2^n$

The pumping lemma specifies that w is still in the langauge for all $i \geq 0, xy^iz∈L$. 

Consider the word w 012:

$w = xyz = 012$

y can be seleected to be any of the following:

1\. y = 012

2\. y = 01

3\. y = 12

4\. y = 1

1\. For y = 012 and i = 2, the produced string 012012 is not in the language.

2\. For y = 01 and i = 2, the produced string 01012 is not in the langauge.

3\. For y = 12 and i = 2, the produced string 01212 is not in the language.

4\. For y = 1 and i = 2, the produced string 0112 is not in the language.

We are unable to select a value for y that satisifies the pumping lemma, therefore this is not a regular language by contradiction.

b\. $A_{2} = \{ www|w \in \left\{ a,b \right\}^{*}\}$

(20 points) 2.4 Give context-free grammars that generate the following
languages. In all parts the alphabet Σ is {0, 1}.

b\. {w | w starts and ends with the same symbol}

```python
from nltk import CFG

grammar = CFG.fromstring("""
S -> '0' Any '0'
S -> '1' Any '1'
S -> '0' | '1'
Any -> '0' Any
Any -> '1' Any
Any ->
""")

from nltk.parse.generate import generate

print([''.join(s) for s in generate(grammar, depth=5)])
```

c\. {w | the length of w is odd|

```python
grammar = CFG.fromstring("""
S -> OneCount EvenCount
OneCount -> '0' | '1'
EvenCount -> OneCount OneCount
EvenCount -> 
""")

print([''.join(s) for s in generate(grammar, depth=5)])
```

(10 points) Figure 2.17 shows a push down automata which recognizes
{a^i^b^j^c^k^| i, j, k≥0 and i=j or i=k}. Please design and draw a new
push down automat which recognizes {a^i^b^j^c^k^| i, j, k≥0 and i≥j or
i≥k}.

![](./media/image1.png){width="2.750285433070866in"
height="1.8020833333333333in"}

(10 points) 2.14 Convert the following CFG into an equivalent CFG in
Chomsky normal form, using the procedure given in Theorem 2.9.

A→BAB|B|ε

B→00|ε

(10 points) 2.30 Use the pumping lemma to show that the following
languages are not context free.

a\. $\left\{ 0^{n}1^{n}0^{n}1^{n} \middle| n \geq 0 \right\}$

(10 points) Answer the following two questions:

a.  Briefly describe how regular language is used for lexical analysis
    in a compiler.

b.  Briefly describe how context free language is used for parsing
    (syntax analysis) in a compiler.

(20 points) Programming Assignments

This programming assignment assumes you have a Linux compiling
environment. If you don’t have one, setting up a Linux machine in a
VirtualBox or VMware Player is a quick way to get a Linux development
environment. If you need help to set up a Linux virtual machine, let me
know.

Assume you have an Ubuntu Linux, you need to install additional packages
to complete the lab. These packages include, flex and bison. You can
install these packages by running the following commands:

&gt;apt-get install flex

&gt;apt-get install bison

A homework2.zip file has been posted in the class website. The zip file
includes three folders, q1, q2, and q3. Each folder contains the
necessary files to finish each question.

**(4 points)** 1) When you use gcc compile a program, e.g., hello.c

&gt;gcc hello.c –o hello

It will create a binary file. You can also check the temporary output
files created by gcc using option –save-temps. Try

&gt;gcc hello.c –o hello –save-temps

and find out what intermediate output files can be produced by gcc.
Briefly describe each intermediate output file.

A typically C compilation pipeline is handled in 4 phases using 4 distinct tools:

1. Pre-processor
  - Expands Macros
  - Handles includes
  - In a nutshell, it takes care of anything starting with `#`
  - With `--save-temps` the output of this phase is stored in `hello.i`
  - This output of this step is valid C code.
2. Compiler
  - Converts pre-processed C code into assembly instructions
  - Compilation could output machine code directly, but using intermediate assembly modularizes the tool chain. Also, because C allows inline assembly, you need a full assembler anyhow.
  - The output of this step is stored in `hello.s`, and is stored as assembly instructions viewable as text.
  ```asm
	.file	"hello.c"
	.section	.rodata
.LC0:
	.string	"hello world"
	.text
	.globl	main
	.type	main, @function
main:
.LFB2:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$.LC0, %edi
	call	puts
	nop
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE2:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9) 5.4.0 20160609"
	.section	.note.GNU-stack,"",@progbits
  ```
  - It's worth noting that while an intermediate human-readable representation is handy, it isn't strictly necessary. This representation also doesn't need to actually be assembly language instructions for the target platform. For example, LLVM uses a platform independent intermediate representation.
3. Assembler
  - The assembler converts assembly instructions to machine code
  - The output of this stage is stored as `hello.o`
  - This stage is notable as this output is frequently generated as part of a "normal" build process. Typically, many C files are assembled and then linked into a single final executable.
  - Being machine code, we can't easily view .o files directly. They can be viewed with a hex editor, but that's fairly painful. GCC does include a tool called objdump to allow us to disassemble obejct files. Here's the output of `objdump -D hello.o` to demonstrate that the object file basically contains out previous assembly code:
  ```
hello.o:     file format elf64-x86-64
 
 
 Disassembly of section .text:
 
 0000000000000000 <main>:
    0:	55                   	push   %rbp
    1:	48 89 e5             	mov    %rsp,%rbp
    4:	bf 00 00 00 00       	mov    $0x0,%edi
    9:	e8 00 00 00 00       	callq  e <main+0xe>
    e:	90                   	nop
    f:	5d                   	pop    %rbp
   10:	c3                   	retq   
 
 Disassembly of section .rodata:
 
 0000000000000000 <.rodata>:
    0:	68 65 6c 6c 6f       	pushq  $0x6f6c6c65
    5:	20 77 6f             	and    %dh,0x6f(%rdi)
    8:	72 6c                	jb     76 <main+0x76>
    a:	64                   	fs
 	...
 
 Disassembly of section .comment:
 
 0000000000000000 <.comment>:
    0:	00 47 43             	add    %al,0x43(%rdi)
    3:	43 3a 20             	rex.XB cmp (%r8),%spl
    6:	28 55 62             	sub    %dl,0x62(%rbp)
    9:	75 6e                	jne    79 <main+0x79>
    b:	74 75                	je     82 <main+0x82>
    d:	20 35 2e 34 2e 30    	and    %dh,0x302e342e(%rip)        # 302e3441 <main+0x302e3441>
   13:	2d 36 75 62 75       	sub    $0x75627536,%eax
   18:	6e                   	outsb  %ds:(%rsi),(%dx)
   19:	74 75                	je     90 <main+0x90>
   1b:	31 7e 31             	xor    %edi,0x31(%rsi)
   1e:	36 2e 30 34 2e       	ss xor %dh,%cs:(%rsi,%rbp,1)
   23:	39 29                	cmp    %ebp,(%rcx)
   25:	20 35 2e 34 2e 30    	and    %dh,0x302e342e(%rip)        # 302e3459 <main+0x302e3459>
   2b:	20 32                	and    %dh,(%rdx)
   2d:	30 31                	xor    %dh,(%rcx)
   2f:	36 30 36             	xor    %dh,%ss:(%rsi)
   32:	30 39                	xor    %bh,(%rcx)
 	...
 
 Disassembly of section .eh_frame:
 
 0000000000000000 <.eh_frame>:
    0:	14 00                	adc    $0x0,%al
    2:	00 00                	add    %al,(%rax)
    4:	00 00                	add    %al,(%rax)
    6:	00 00                	add    %al,(%rax)
    8:	01 7a 52             	add    %edi,0x52(%rdx)
    b:	00 01                	add    %al,(%rcx)
    d:	78 10                	js     1f <.eh_frame+0x1f>
    f:	01 1b                	add    %ebx,(%rbx)
   11:	0c 07                	or     $0x7,%al
   13:	08 90 01 00 00 1c    	or     %dl,0x1c000001(%rax)
   19:	00 00                	add    %al,(%rax)
   1b:	00 1c 00             	add    %bl,(%rax,%rax,1)
   1e:	00 00                	add    %al,(%rax)
   20:	00 00                	add    %al,(%rax)
   22:	00 00                	add    %al,(%rax)
   24:	11 00                	adc    %eax,(%rax)
   26:	00 00                	add    %al,(%rax)
   28:	00 41 0e             	add    %al,0xe(%rcx)
   2b:	10 86 02 43 0d 06    	adc    %al,0x60d4302(%rsi)
   31:	4c 0c 07             	rex.WR or $0x7,%al
   34:	08 00                	or     %al,(%rax)
 	...
 	``` 
4. Linker
  - Merges object file(s) into a single final executable
  - Adds necessary bootstraping code to start execution, handles environment and command line variables, etc.
  - Converts references to external code to the correct locations.
  - The linker may run dynamically to call into dynamically loaded dependencies, or it can be run statically to include all dependencies directly in the final binary. 
  - The output of this stage is the final executable, `hello`.
  - This stage is also hard to view directly, but we can still use `objdump` to convert it to assembly for debugging. I won't include this inline as it is much longer than the above.

**(8 points)** 2) The flex file, calc.lex, is a simple calculator. You
can compile the file with the following commands:

&gt; flex calc.lex; gcc -o calc lex.yy.c

You can then run the calculator with the 'calc' command and can quit out
of it using ctrl-d.

Do the following and submitted your modified code:

-   Add division and subtraction to the calculator.

```
diff --git a/q2/calc.lex b/q2/calc.lex
index 101c022..01e6612 100644
--- a/q2/calc.lex
+++ b/q2/calc.lex
@@ -32,7 +32,9 @@ struct tokenInfo2 yylval;
 
 :=    printf("ASSIGNMENT\n");
 \+     printf("PLUS\n");
+\-     printf("MINUS\n");
 \*     printf("MULTIPLY\n");
+\/     printf("DIVIDE\n");
 
 \n    printf("NEWLINE\n");
```

-   Keep track of the number of lines that have been input. Make sure
    that you set the lineNumber variable in yylval.ti for each token and
    print out the line count when you print out variable information.

```
diff --git a/q2/calc.lex b/q2/calc.lex
index 01e6612..b91c8a0 100644
--- a/q2/calc.lex
+++ b/q2/calc.lex
@@ -21,7 +21,7 @@ struct tokenInfo2 yylval;
 [a-z]   {
 	   yylval.ti.value = 0;
 	   yylval.ti.name =  (char *) strdup(yytext);
-	   printf("VARIABLE: %s\n", yylval.ti.name);
+	   printf("VARIABLE: %s LINES: %d\n", yylval.ti.name, yylval.ti.lineNumber);
         }
 
 [0-9]+  {  
@@ -36,7 +36,10 @@ struct tokenInfo2 yylval;
 \*     printf("MULTIPLY\n");
 \/     printf("DIVIDE\n");
 
-\n    printf("NEWLINE\n");
+\n      {
+           printf("NEWLINE\n");
+           yylval.ti.lineNumber += 1;
+        }
 
 [ \t]   ;
```

-   Extend the variables to handle longer variable names. The variables
    must start with an alphabetic character or '\_' character and may be
    followed by 0 or more alphabetic/numerical/'\_'/'-' characters.

```
diff --git a/q2/calc.lex b/q2/calc.lex
index b91c8a0..9857abd 100644
--- a/q2/calc.lex
+++ b/q2/calc.lex
@@ -18,7 +18,7 @@ struct tokenInfo2 yylval;
 
 %%
 
-[a-z]   {
+[a-zA-Z_][a-zA-Z0-9_\-]*   {
 	   yylval.ti.value = 0;
 	   yylval.ti.name =  (char *) strdup(yytext);
 	   printf("VARIABLE: %s LINES: %d\n", yylval.ti.name, yylval.ti.lineNumber);
```

**(8 points)** 3) A flex file, calc.lex, a bison file, calc.y, and a
Makefile are provide in homework2 q3 folder. You can compile the flex
file and the bison file by running

&gt;make

A binary execution file, calc, will be created.

You can then run the calculator with the 'calc' command and can quit out
of it using “quit”.

Do the following and submitted your modified code:

-   Extend the calculator to support power operator, ‘\^’. Let x, y are
    two numbers, ${x\hat{}y = x}^{y}$.

```
diff --git a/q3/Makefile b/q3/Makefile
index d002bb4..3f2fd68 100644
--- a/q3/Makefile
+++ b/q3/Makefile
@@ -7,7 +7,7 @@ lex.yy.c: calc.lex calc.tab.h
 	flex calc.lex
 
 calc: lex.yy.c calc.tab.c calc.tab.h
-	gcc -o calc calc.tab.c lex.yy.c -lfl
+	gcc -o calc calc.tab.c lex.yy.c -lfl -lm
 
 test: calc
 	echo "1+1" | ./calc | grep 2
diff --git a/q3/calc.lex b/q3/calc.lex
index 975e718..5153c79 100644
--- a/q3/calc.lex
+++ b/q3/calc.lex
@@ -16,6 +16,7 @@
 "-"	{return '-';}
 "*"	{return '*';}
 "/"	{return '/';}
+"^"	{return '^';}
 "quit"	{return QUIT;}
 
 %%
diff --git a/q3/calc.y b/q3/calc.y
index 29a338d..a2451de 100644
--- a/q3/calc.y
+++ b/q3/calc.y
@@ -20,6 +20,7 @@ void yyerror(const char* s);
 %token QUIT
 %left '+' '-'
 %left '*' '/'
+%left '^'
 
 %type<ival> exp
 
@@ -41,6 +42,7 @@ exp: NUM		{ $$ = $1; }
     | exp '-' exp	{ $$ = $1 - $3; }
     | exp '*' exp	{ $$ = $1 * $3; }
     | exp '/' exp	{ $$ = $1 / $3; }
+    | exp '^' exp	{ $$ = pow($1, $3); }
 ;
 
 %%
```

-   Extend the calculator to support parentheses, ‘(‘, and ‘)’. An
    expression inside parentheses needs to be evaluated first, e.g.,
    enter 2 \* ( 3 + 2) in the calculator and it should return 10.

```
diff --git a/q3/calc.lex b/q3/calc.lex
index 5153c79..c20788f 100644
--- a/q3/calc.lex
+++ b/q3/calc.lex
@@ -17,6 +17,8 @@
 "*"	{return '*';}
 "/"	{return '/';}
 "^"	{return '^';}
+"("	{return '(';}
+")"	{return ')';}
 "quit"	{return QUIT;}
 
 %%
diff --git a/q3/calc.y b/q3/calc.y
index a2451de..3e84c55 100644
--- a/q3/calc.y
+++ b/q3/calc.y
@@ -18,6 +18,7 @@ void yyerror(const char* s);
 
 %token<ival> NUM
 %token QUIT
+%left '(' ')'
 %left '+' '-'
 %left '*' '/'
 %left '^'
@@ -38,6 +39,7 @@ line: '\n'
 ;
 
 exp: NUM		{ $$ = $1; }
+    | '(' exp ')' { $$ = $2; }
     | exp '+' exp	{ $$ = $1 + $3; }
     | exp '-' exp	{ $$ = $1 - $3; }
     | exp '*' exp	{ $$ = $1 * $3; }

```